# YY.YellowPlatformFormats [![NuGet version](https://badge.fury.io/nu/YY.YellowPlatformFormats.svg)](https://badge.fury.io/nu/YY.YellowPlatformFormats)

Библиотека для работы с типами данных платформы 1С:Предприятние 8.x из .NET.

Позволяет обрабатывать различные форматы данных, присланные через веб-сервис, файлы или другие виды транспорта.

Текущая версия с большими ограничениями, много что не учтено и требует доработки.

## Краткое описание

Основные функции библиотеки:
* Преобразование внутреннего формата данных 1С в типа .NET.
* Сериализация объектов .NET во внутренний формат 1С.
* Поддержка некоторых специфичных действия с данными 1С.

В основном библиотека сделана для узких задач интеграции, которые чаще всего можно избежать. Поэтому дважды подумайте нужно ли Вам использовать типы данных 1С в своих приложениях.

Список поддерживаемых типов:
* Null
* Неопределено
* Число
* Строка
* Булево
* Дата
* Массив
* Структура
* Соответствие
* Таблица значений
* Фиксированный массив
* Фиксированная структура
* Фиксированное соответствие
* Хранилище значений

## Примеры использования

Все очень просто. Например, в 1С есть тип "Структура". Создаем структуру, помещаем ее в хранилище значений и передаем каким-либо путем в среду испольнения .NET (C#). Например через веб-сервис.

Вот создаем сложную структуру на стороне 1С и упаковываем ее в хранилище:

```bsl
ЗначениеСтруктура = Новый Структура;
ЗначениеСтруктура.Вставить("Тест1", 1);
ЗначениеСтруктура.Вставить("Тест2", "Какая-то строка");
ЗначениеСтруктура.Вставить("Объект", Новый Структура("Знач1, Знач2", Null, Неопределено));

// Возвращаем куда-то эти данные
Возврат Новый ХранилищеЗначения(ЗначениеСтруктура, Новый СжатиеДанных(5));
```

На стороне .NET имеет массив байт, который нам нужно обработать и получить данные в читаемом виде:

```csharp
public void DoSomething(byte[] valueFrom1C)
{
	// Работаем с хранилищем значений
	ValueStorage storage = new ValueStorage(valueFrom1C);
	// Получаем значение из хранилища в виде строки внутреннего формата 1С
	var storageAsIntarnalString = storage.GetRawValueAsString();
	// Сериализуем строку в нужный объект
	var valueFromStorage = new Structure(storageAsIntarnalString);
	// Получаем значение из структуры
	var valueFromStructure = (Structure)valueFromStorage["Объект"];
	// Из вложенного объекта получаем еще свойство
	var someOtherValue = valueFromStructure["Знач1"];
}
```

Объект 1С во внутренем строковом формате 1С будет выглядеть таким образом:
```
{"#",4238019d-7e49-4fc9-91db-b6b951d5cf8e,{3,
        {
            {"S","Тест1"},
            {"N",1.00}
        },
        {
            {"S","Тест2"},
            {"S","Какая-то строка"}
        },
        {
            {"S","Объект"},
            {"#",4238019d-7e49-4fc9-91db-b6b951d5cf8e,{2,
                    {
                        {"S","Знач1"},{"L"}
                    },
                    {
                        {"S","Знач2"},{"U"}
                    }
                }
            }
        }
    }
}
```

Таким образом, это значение мы трансформировали в тип "Structure" и уже работали с ним в более менее удобном виде.

Аналогично этот же объем можно полностью создать программно:
```csharp
Structure value = new Structure();
value.Insert("Тест1", 1M);
value.Insert("Тест2", "Какая-то строка");
Structure value2 = new Structure();
value2.Insert("Знач1", NullValue.Default);
value2.Insert("Знач2", UndefinedType.Default);
value.Insert("Объект", value2);

// А после получить эти "страшные кракозябры" в виде строки
string internalString = ObjectToInternalStringConverter.ValueToStringInternal(value);
```

На этом и весь пример.

## Связанные материалы

* Используется библиотека [OneSTools.BracketsFile](https://github.com/akpaevj/OneSTools.BracketsFile) для разбора "скобочного" формата.
* Хорошее описание внутреннего формата 1С в публикации [Описание формата внутреннего представления данных 1С в контексте обмена данными](https://infostart.ru/1c/articles/1116103/#Структура).

## TODO

* Рефакторинг модулей
* Добавление проверок данных
* Поддержка большего числа типов данных и операций с ними
* Улучшить архитектуру работы с типами

## Лицензия

MIT - делайте все, что посчитаете нужным. Никакой гарантии и никаких ограничений по использованию.
